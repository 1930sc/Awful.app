//  UserDefaults+Settings.swift
//
//  Copyright 2019 Awful Contributors. CC BY-NC-SA 3.0 US https://github.com/Awful/Awful.app

import Foundation

extension UserDefaults {
    
    /**
     Keys used to store Awful's settings in UserDefaults.
     
     KVO-compliant properties are generated by Sourcery (see `UserDefaults+Settings.stencil` and `UserDefaults+Settings.generated.swift`). The value type is assumed to be `Bool` when not otherwise specified.
     */
    enum SettingsKeys {
        static let automaticallyEnableDarkMode = "auto_dark_theme"
        static let automaticallyPlayGIFs = "autoplay_gifs"
        /// sourcery: valueType = Double
        static let automaticDarkModeBrightnessThresholdPercent = "auto_theme_threshold"
        static let confirmNewPosts = "confirm_before_replying"
        /// sourcery: valueType = String?
        static let customBaseURLString = "custom_base_URL"
        static let embedTweets = "embed_tweets"
        /// sourcery: valueType = Double
        static let fontScale = "font_scale"
        static let hideSidebarInLandscape = "hide_sidebar_in_landscape"
        static let isAlternateThemeEnabled = "alternate_theme"
        static let isDarkModeEnabled = "dark_theme"
        static let isHandoffEnabled = "handoff_enabled"
        static let isPullForNextEnabled = "pull_for_next"
        /// sourcery: valueType = String?
        static let lastOfferedPasteboardURLString = "last_offered_pasteboard_URL"
        static let loggedInUserCanSendPrivateMessages = "can_send_private_messages"
        /// sourcery: valueType = String?
        static let loggedInUserID = "userID"
        /// sourcery: valueType = String?
        static let loggedInUsername = "username"
        static let openCopiedURLAfterBecomingActive = "clipboard_url_enabled"
        static let openTwitterLinksInTwitter = "open_twitter_links_in_twitter"
        static let openYouTubeLinksInYouTube = "open_youtube_links_in_youtube"
        static let postLargeImagesAsThumbnails = "automatic_timg"
        static let showAuthorAvatars = "show_avatars"
        static let showImages = "show_images"
        static let showThreadTagsInThreadList = "show_thread_tags"
        static let showTweaksOnShake = "show_tweaks_on_shake"
        static let showUnreadAnnouncementsBadge = "show_unread_announcements_badge"
        static let sortUnreadBookmarksFirst = "bookmarks_sorted_unread"
        static let sortUnreadForumThreadsFirst = "forum_threads_sorted_unread"
    }
}

extension UserDefaults {
    
    /// Some settings are a bit more effort and it's not worth customizing the Sourcery template just for them.
    private enum MoreSettingsKeys {
        static let ubiquitousThemeNames = "ubiquitous_theme_names"
    }
    
    @objc dynamic var ubiquitousThemeNames: [String]? {
        get { return object(forKey: MoreSettingsKeys.ubiquitousThemeNames) as? [String] }
        set { set(newValue, forKey: MoreSettingsKeys.ubiquitousThemeNames) }
    }
    
    @objc private class var keyPathsForValuesAffectingUbiquitousThemeNames: Set<String> {
        return [MoreSettingsKeys.ubiquitousThemeNames]
    }
}

extension UserDefaults {
    
    /**
     Calls a closure whenever the value for a particular keypath is changed.
     
     Unlike the closure passed to `observe(_:options:changeHandler:)`, this changeHandler is always called on the main queue.
     
     Also, including `.new` for the `options` parameter here doesn't seem to result in the closure getting passed anything for `change.newValue`. Not sure if we're doing something weird here, but it's actually easier to just ask the `UserDefaults` instance for the current value anyway, so that's the recommended approach.
     */
    func observeOnMain<Value>(
        _ keyPath: KeyPath<UserDefaults, Value>,
        options: NSKeyValueObservingOptions = [],
        changeHandler: @escaping (UserDefaults, NSKeyValueObservedChange<Value>) -> Void)
        -> NSKeyValueObservation
    {
        return observe(keyPath, options: options, changeHandler: { object, change in
            DispatchQueue.main.async {
                changeHandler(object, change)
            }
        })
    }
    
    /**
     Add several `UserDefaults` observers at once. Each observer will be called on the main queue.
     
     For example:
     
     var observers: [NSKeyValueObservation] = []
     
     observers += UserDefaults.standard.observeSeveral {
         $0.observe(\.showAvatars) { defaults in
             print("showAvatars is now \(defaults.showAvatars)")
         }
     }
     
     Note that there's no provision for `NSKeyValueObservingOptions` or `NSKeyValueObservedChange`; this is a convenience method for adding several observers that react to settings changes, and the assumption is that the current value is desired and will be obtained from the passed-in `UserDefaults` instance (as in the example).
     */
    func observeSeveral(_ block: (ObserveSeveralHelper) -> Void) -> [NSKeyValueObservation] {
        let helper = ObserveSeveralHelper(self)
        block(helper)
        return helper.observers
    }
    
    /// - Seealso: `UserDefaults.observeSeveral(_:)`.
    final class ObserveSeveralHelper {
        private let defaults: UserDefaults
        fileprivate var observers: [NSKeyValueObservation] = []
        
        fileprivate init(_ defaults: UserDefaults) {
            self.defaults = defaults
        }
        
        /**
         Add a key-value observer for each provided key path. The change handler is called on the main queue whenever any of the key paths change.
         
         The added observers are all included in the return value from `UserDefaults.observeSeveral(_:)`.
         */
        func observe<Value>(_ keyPaths: KeyPath<UserDefaults, Value>..., changeHandler: @escaping (UserDefaults) -> Void) {
            observers += keyPaths.map {
                defaults.observeOnMain($0, changeHandler: { defaults, change in
                    changeHandler(defaults)
                })
            }
        }
    }
}
